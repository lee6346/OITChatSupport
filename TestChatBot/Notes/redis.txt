Redis Stack exchange

Azure tutorials (.NET)
	1. Create a connection 
		- wrapper around ConnectionMultiplexer must be singlton (make sure autofac registers as singleton)
	
	2. Start connection (static method)
		ConnectionMultiplexer conn = ConnectionMultiplexer.Connect("connString");
			for production server, you need to configure the following
			- abortConnect=true/false
			- ssl=true/false
	3. Since only one instance of multiplexer, you can share using static property t oreturn a connected instance (thread safe and easy)
		private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
		{
			return ConnectionMultiplexer.Connect("contoso5.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
		});
		public static ConnectionMultiplexer Connection
		{
			get { return lazyConnection.Value; }
		}
	4. return a referene to the redis cache database 
		IDatabase cache = Connection.GetDatabase();
		cache.StringSet("Key1", "Vlaue1");
		var x = cache.StringGet("Key1");

	5. stackexchange redis treats the key as both string and byte[] implicitly so its safe to use them interchangeable
		- configure so if cahce miss, retrieve from DB then store into cache for next time
		string val = cache.StringGet("key1");
		if(value==null)
		{
			value = SqlDb.Get(x => x....);
			cache.StringSet("key", value);
		}
	6. Time options: cache.StringSet("k", "v", TimeSpan.FromMinutes(90));
	7. Serialzing data
		- common/basic way is to use JsonConvert serialze methods from Netwonsoft.Json.NET
		class Employee{..}
		cache.StringSet("e25", JsonConvert.SerializeObject(new Employee(25, "james")));
		var employee = Json.Convert.DeserialzeObject<Employee>(cache.StringGet("e25"));

		- using binary formatter class: the POCO object needs the [Serializable] attribute to use this 
		(assume attribute exists)
		Poco myPoco = new Poco {..};
		string key = "keyForPoco";
		byte[] bytes;
		using (var stream = new MemoryStream())
		{
			new BinaryFormatter().Serialize(stream, myPoco);
			bytes = stream.ToArray();
		}
		db.StringSet(key, bytes);
		//to get
		string key = "myObj";
		Poco myPoco = null;
		byte[] bytes = (byte[])db.StringGet(key);
		if(bytes != null)
		{
			using(var stream = new MemoryStream(bytes))
			{
				myPoco = (Poco) new BinaryFormatter().Deserialize(stream);
			}
		}

Basic Configuration : https://stackexchange.github.io/StackExchange.Redis/Configuration
	var conn = ConnectionMultiplexer.Connect("localhsot"); // uses default 6379
	var conn = ConnectionMultiplexer.Connect("redis0:6380,redis1:6380,allowAdmin=true");

	- ConfigurationOptions can be representing as string
		ConfigurationOptions opt = ConfigurationOptions.Parse(configString); string configString = opt.ToString();
	// to do at runtime
		string configString = GetRedisConfiguration();
		var options = ConfigurationOptions.Parse(configString);
		options.ClientName = GetAppName(); // only known at runtime
		options.AllowAdmin = true;
		conn = ConnectionMultiplexer.Connect(options);

All config options
	abortConnect=bool: default=true, | allowAdmin=bool: default=false, | connectRetry=int: default=3,
	connectTimeout=int: default=5000(ms), | keepAlive=int: default=-1 (60 sec) , time in secs at which to send message to help keep sockets alive 
	name=string: default=null, client name | password=string: default=null, client password for redis server
	ssl=bool: default=false, for ssl encrption | writeBuffer=int; default=4096 bytes for output buffer

Custom configuring (override defaults): same as -> redis0:6379,redis1:6380,keepAlive=180,version=2.8.8,$CLIENT=,$CLUSTER=,$CONFIG=,$ECHO=,$INFO=,$PING=
	ConfigurationOptions config = new ConfigurationOptions
	{
		EndPoints =
		{
			{ "redis0", 6379 },
			{ "redis1", 6380 }
		},
		CommandMap = CommandMap.Create(new HashSet<string>
		{
			"INFO", "CONFIG", "CLUSTER",
			"PING", "ECHO", "CLIENT"
		}, available: false),
		KeepAlive = 180,
		DefaultVersion = new Version(2, 8, 8),
		Password = "changeme"
	};
Rename/disable commands: (not recommended), same as -> $INFO=,$SELECT=use
	var commands = new Dictionary<string,string> {
			{ "info", null }, // disabled
			{ "select", "use" }, // renamed to SQL equivalent for some reason
	};
	var options = new ConfigurationOptions {
		CommandMap = CommandMap.Create(commands),
	}

Reconnect Retry policy
	config.ReconnectRetryPolicy = new ExponentialRetry(5000); // defaults maxDeltaBackoff to 10000 ms
	//retry#    retry to re-connect after time in milliseconds
	//1	        a random value between 5000 and 5500	   
	//2	        a random value between 5000 and 6050	   
	//3	        a random value between 5000 and 6655	   
	//4	        a random value between 5000 and 8053
	//5	        a random value between 5000 and 10000, since maxDeltaBackoff was 10000 ms
	config.ReconnectRetryPolicy = new LinearRetry(5000);
	//retry#    retry to re-connect after time in milliseconds
	//1	        5000
	//2	        5000 	   
	//3	        5000 	   
	....

Pipelines
	process of sending multiple messages down the pipe in bulk instead of waiting for each reply before sending next
	- works with .NET's Tasks and threading (Wait(), WaitAll(), await/async, ContinueWith(), etc)
		var aPending = db.StringGetAsync("a");
		var bPending = db.StringGetAsync("b");
		Task.WaitAll(aPending, bPending)
Fire and Forget:
	don't care about result, use flags param, which returns the default false value instead of actual result, but just ignore 
	db.KeyExpire(key, TimeSpan.FromMinutes(5), flags: CommandFlags.FireAndForget);
	var value = (string)db.StringGet(key);

Multiplexing:
	sub.Subscribe(channel, delegate {
		string work = db.ListRightPop(key);
		if (work != null) Process(work);
	});
	db.ListLeftPush(key, newWork, flags: CommandFlags.FireAndForget);
	sub.Publish(channel, "");

Concurrency:
	string value = await db.StringGetAsync(key);
	if (value == null) {
		value = await ComputeValueFromDatabase(...);
		db.StringSet(key, value, flags: CommandFlags.FireAndForget);
	}
	return value;

Transactions:
	different from sql, consists of a block of commands between MULTI and EXEC (or DISCARD for rolling back)
	- once MULTI has been read, the commands on that conection arent executed, they are queued and the MULTI caller gets the reply QUEUED to each
	- once EXEC is encoundered, all commited in single unit (w/o other connections getting between between ops) (for DISCARD, everything rolled back as unit and discared)
	// assign a new unique id only if they don't already, have one, in a transaction to ensure no thread-races
	var newId = CreateNewUniqueID(); // optimistic
	using(var tran = conn.BeginTran())
	{
		var cust = GetCustomer(conn, custId, tran);
		var uniqueId = cust.UniqueID;
		if(uniqueId == null)
		{
			cust.UniqueId = newId;
			SaveCustomer(conn, cust, tran);
		}
		tran.Complete();
	}
	var newId = CreateNewId();
	var tran = db.CreateTransaction();
	tran.AddCondition(Condition.HashNotExists(custKey, "UniqueID"));
	tran.HashSetAsync(custKey, "UniqueID", newId);
	bool committed = tran.Execute();
	// ^^^ if true: it was applied; if false: it was rolled back

InBuilt operations via When
	- redis has its own built-in basic operations such as When
	var newId = CreateNewId();
	bool wasSet = db.HashSet(custKey, "UniqueID", newId, When.NotExists);

Lua: redis 2.6 + support lua scripe for perfforming multi operations as single atomic unit at server
- behave like transaction but without complexity of MULTI + EXEC
var wasSet = (bool) db.ScriptEvaluate(@"if redis.call('hexists', KEYS[1], 'UniqueId') then return redis.call('hset', KEYS[1], 'UniqueId', ARGV[1]) else return 0 end",
        new RedisKey[] { custKey }, new RedisValue[] { newId });

REdis KEys, Values, Channels
	Key: can be string, list, hash, or any other redis data type
		- defines the node, 
		- crucial for routing commands
	Values: things to store against keys, they don't affect command routing (except for SORT command when BY or GET is specified)
		- generally interpreted by redis only for purpose of operations
			Ex: incr, sorting, etc
	Channels: for pub/sub we deal with channels that don't affect routing (they arent keys)
	.NET, the RedisKey type has implicit conversation to/from both string and byte allowing both text/binary keys to be used without complication
			string key = ... 
			db.StringIncrement(key);
			byte[] key = ...
			db.StringIncrement(key);
		Also operations that return keys as Redis key
			string key = db.KeyRandom()
	Values .NET
		db.StringSet("ley", val)
		- value can be representing by text, binary, and allow EXPLICIT (type cast) conversion
		int i = (int)db.StringGet("myKey");
		- when typecasting, null values in the cache typecast to numerics = 0
Events:
	ConnectionMultiplexer tpye exposes many events  which can be useful for logging purposes
	ConfigurationChanged, ConnectionFailed, ConnectionRestored, ErrorMessage
	HashSlotMoved, InternalError, ConfigartionChangedBroadcast

KEysScan, 
	Certain operatoins (KEYS, FLUSHDB, etc) can only be used if starting from server, not a dataabse
	// get the target server
	var server = conn.GetServer(someServer);
	// show all keys in database 0 that include "foo" in their name
	foreach(var key in server.Keys(pattern: "*foo*")) {
		Console.WriteLine(key);
	}
	// completely wipe ALL keys from database 0
	server.FlushDatabase();

Sample by Azure team (condensed class without all the methods)
	public class RedisCache : IRepositoryCache
	{
	  private static ConfigurationOptions _configurationOptions;
	  private readonly CachePrefix _prefix;
	  public RedisCache(ConfigurationOptions configurationOptions, CachePrefix prefix)
	  {
		if (configurationOptions == null) throw new ArgumentNullException("configurationOptions");
		_configurationOptions = configurationOptions;
		_prefix = prefix;
	  }
	  private static IDatabase Cache
	  {
		get { return Connection.GetDatabase(); }
	  }
	  private static readonly Lazy<ConnectionMultiplexer> LazyConnection = new Lazy<ConnectionMultiplexer>(() => ConnectionMultiplexer.Connect(_configurationOptions));
	  public static ConnectionMultiplexer Connection
	  {
		get { return LazyConnection.Value; }
	  }
	  public void ClearItem(string key)
	   {
		 key = _prefix + key;
		 if (key == null) throw new ArgumentNullException("key");
		 Cache.KeyDelete(key);
	   }
	}

Sample: https://ruhul.wordpress.com/2014/07/23/use-redis-as-cache-provider/
1. make cache store layer interface
public interface ICacheStore
{
    bool Exists(string key);
    T Get<T>(string key);
    void Set<T>(string key, T value, TimeSpan expiredIn);
    void Remove(string key);
 
    Task<bool> ExistsAsync(string key);
    Task<T> GetAsync<T>(string key);
    Task SetAsync<T>(string key, T value, TimeSpan expiredIn);
    Task RemoveAsync(string key);
}

2. implement it
public class RedisCacheStore : ICacheStore
{
    private readonly IDatabase _database;
    private readonly ISerializer _serializer;
    private readonly CommandFlags _readFlag;
    public RedisCacheStore(IRedisConnectionWrapper connectionWrapper, IRedisServerSettings settings, ISerializer serializer)
    {
        _database = connectionWrapper.Database(settings.DefaultDb);
        _serializer = serializer;
        _readFlag = settings.PreferSlaveForRead ? CommandFlags.PreferSlave : CommandFlags.PreferMaster;
    }
    async Task<bool> ICacheStore.ExistsAsync(string key)
    {
        return await _database.KeyExistsAsync(key);
    }
    async Task<T> ICacheStore.GetAsync<T>(string key)
    {
        var result = await _database.StringGetAsync(key, _readFlag);
        return _serializer.Deserialize<T>(result);
    }
    async Task ICacheStore.SetAsync<T>(string key, T value, TimeSpan expiredIn)
    {
        await _database.StringSetAsync(key, _serializer.Serialize(value), expiredIn);
    }
    async Task ICacheStore.RemoveAsync(string key)
    {
        await _database.KeyDeleteAsync(key);
    }
    bool ICacheStore.Exists(string key)
    {
        return _database.KeyExists(key, _readFlag);
    }
    T ICacheStore.Get<T>(string key)
    {
        return _serializer.Deserialize<T>(_database.StringGet(key, CommandFlags.PreferSlave));
    }
    void ICacheStore.Set<T>(string key, T value, TimeSpan expiredIn)
    {
        _database.StringSet(key, _serializer.Serialize(value), expiredIn);
    }
    void ICacheStore.Remove(string key)
    {
        _database.KeyDelete(key);
    }
}

3. notice that there are 3 dependencies: redis wrapper, redis options, serializer
- the serializer allows you to use redis client extensions to serialize as bson, json, protobuff, etc, etc
- we are using JSON serialzer so lets create the interface and implementation
public interface ISerializer
{
    string Serialize<T>(T data);
    T Deserialize<T>(string serializedData);
}
public class JsonSerializer : ISerializer
{
	private readonly JsonSerializerSettings _settings;
	public JsonSerializer()
	{
		_settings = new Newtonsoft.Json.JsonSerializerSettings
		{
			ContractResolver = new CamelCasePropertyNamesContractResolver(),
			NullValueHandling = NullValueHandling.Ignore,
			DateTimeZoneHandling = DateTimeZoneHandling.Utc
		};
		_settings.Converters.Add(new StringEnumConverter());
	}
	string ISerializer.Serialize<T>(T value)
	{
		return JsonConvert.SerializeObject(value, _settings);
	}
	T ISerializer.Deserialize<T>(string value)
	{
		return JsonConvert.DeserializeObject<T>(value, _settings);
	}
}

4. Next we define the interface and implemnentation for the redis connection wrapper
- the wrapper must be registered as a singleton since it holds the multiplexer!
= notice that redis does not benfit from the concurrency resolutions of SQL, thus we use a _lock
public interface IRedisConnectionWrapper : IDisposable
{
    IDatabase Database(int? db = null);
    IServer Server(EndPoint endPoint);
    EndPoint[] GetEndpoints();
    void FlushDb(int? db = null);
}
 
 
public class RedisConnectionWrapper : IRedisConnectionWrapper
{
    private readonly IRedisServerSettings _settings;
    private readonly ILogger _logger;
    private readonly Lazy<string> _connectionString;
    private volatile ConnectionMultiplexer _connection;
    private readonly object _lock = new object();
    public RedisConnectionWrapper(IRedisServerSettings settings, ILogger logger)
    {
        _settings = settings;
        _logger = logger;
        _connectionString = new Lazy<string>(GetConnectionString);
    }
    private string GetConnectionString()
    {
        var con = ConfigurationManager.ConnectionStrings[_settings.ConnectionStringOrName];    
        return con == null ? _settings.ConnectionStringOrName : con.ConnectionString;
    }
    private ConnectionMultiplexer GetConnection()
    {
        if (_connection != null && _connection.IsConnected) return _connection;    
        lock (_lock)
        {
            if (_connection != null && _connection.IsConnected) return _connection;
            if (_connection != null)
            {
                _logger.Debug("Connection disconnected. Disposing connection...");
                _connection.Dispose();
            }
            _logger.Debug("Creating new instance of Redis Connection");
            _connection = ConnectionMultiplexer.Connect(_connectionString.Value);
        }
        return _connection;
    }
    public IDatabase Database(int? db = null)
    {
        return GetConnection().GetDatabase(db ?? _settings.DefaultDb);
    }
    public IServer Server(EndPoint endPoint)
    {
        return GetConnection().GetServer(endPoint);
    }
    public EndPoint[] GetEndpoints()
    {
        return GetConnection().GetEndPoints();
    }
    public void FlushDb(int? db = null)
    {
        var endPoints = GetEndpoints();
        foreach (var endPoint in endPoints)
        {
            Server(endPoint).FlushDatabase(db ?? _settings.DefaultDb);
        }
    }
    public void Dispose()
    {
        if (_connection != null)
        {
            _connection.Dispose();
        }
    }
}

5. Finally we need to configure redis settings so lets create th e interface and implementation for that as well
public interface IRedisServerSettings
{
    bool PreferSlaveForRead { get; }
    string ConnectionStringOrName { get; }
    int DefaultDb { get; }
}
public class RedisServerSettings : ConfigurationSection, IRedisServerSettings
{
    public static Lazy<IRedisServerSettings> Settings = new Lazy<IRedisServerSettings>(() => ConfigurationManager.GetSection("Redis.ServerSettings") as RedisServerSettings);
    [ConfigurationProperty("PreferSlaveForRead", IsRequired = false, DefaultValue = false)]
    public bool PreferSlaveForRead { get { return Convert.ToBoolean(this["PreferSlaveForRead"]); } }
    [ConfigurationProperty("ConnectionStringOrName", IsRequired = true)]
    public string ConnectionStringOrName { get { return this["ConnectionStringOrName"] as string; } }
    [ConfigurationProperty("DefaultDb", IsRequired = false, DefaultValue = 0)]
    public int DefaultDb { get { return Convert.ToInt32(this["DefaultDb"]); } }
}
// sample config file
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <configSections>
        <section name="Redis.ServerSettings" type="<full namespace>.RedisServerSettings, <assemblyname>" />
    </configSections>
    <Redis.ServerSettings DefaultDb="3" ConnectionStringOrName="RedisServer" PreferSlaveForRead="true" />
    <connectionStrings>
        <add name="RedisServer" connectionString="<your redis server ip address>:<port>,ConnectRetry=3,
            KeepAlive=180,name=<give a name>,allowAdmin=true,Password=<password if you secured the server>" />
    <connectionStrings>
</configuration>


6. Finally we create a module to register the redis client in our IOC container (this example uses NInject, but autofac works similarly)
public class CacheRepositoryModule : NinjectModule
{
    public override void Load()
    {
        Bind<IRedisServerSettings>().ToMethod(x => RedisServerSettings.Settings.Value).InSingletonScope();
        Bind<IRedisConnectionWrapper>().To<RedisConnectionWrapper>().InSingletonScope();
        Bind<ISerializer>().To<JsonSerializer>().InSingletonScope();
        Bind<ICacheStore>().To<RedisCacheStore>();
    }
}

7. Now we are ready, here is a sample controller that uses it
public static class CacheStoreExtensions
{
    public static T Get<T>(this ICacheStore source, string key, TimeSpan time, Func<T> fetch) where  T : class
    {
        if (source.Exists(key))
        {
            return source.Get<T>(key);
        }
        else
        {
            var result = fetch();
 
            if (result != null)
            {
                source.Set(key, result, time);
            }
 
            return result;
        }
    }
}
public class MenuController : Controller
{
    private const string Key = "MyApp:Categories:All";
    private readonly ICacheStore _cacheStore;
    private readonly ICategoryRepositor _categoryRepository;
 
    public MenuController(ICacheStore cacheStore, ICategoryRepository categoryRepository)
    {
        _cacheStore = cacheStore;
        _categoryRepository = categoryRepository;
    }
 
    [OutputCache(Duration = 3600)]
    [ChildActionOnly]
    public ActionResult CategoryMenu()
    {
        return PartialView(_cacheStore.Get(Key, TimeSpan.FromHours(1), () => _categoryRepository.GetAll()));
    }
}


Ex 3: using autofac, sql, and redis: http://blog.frankdecaire.com/2017/05/17/net-mvc-project-with-autofac-sql-and-redis-cache/

We will implement the following interfaces: IRedisConnectionManager, IRedisCache, IDatabaseContext (EF sql), ISalesProducts (service class)
1. Configure redis cache
	- the RedisConnectionManager object needs to be setup in the OIC container
	- can have local host, port, etc in web.config or manually in the Autofac registration (global.asax.cs)

	builder.Register(c => new RedisConnectionManager("127.0.0.1"))
		.As<IRedisConnectionManager>()
		.PropertiesAutowired()
		.SingleInstance();
	builder.Register(c => new RedisCache(c.Resolve<IRedisConnectionManager>()))
		.As<IRedisCache>()
		.PropertiesAutowired()
		.SingleInstance();

	To use the cahce, wrap the query in your method in a cache return syntax (double return) as follows
	return _cache.Get("ProductList", 60, () =>
	{
	  return (from p in _db.Products select p.Name);
	});
	- the inner return is a standard EF linq query returned via ()=> lambda
	- the wrapper receives it and stores in cahce for 60 minutes, 
	- the _cache.Get() method will check the cache first, if data is there, it returns the data and moves on
	- if not in the cache, it calls the inner function causing the query to be executed
		- the result is then saved to the cache server and then the result returned
		- this guarantees the enxt query in less than 60 minues will be returned from cache fo rdirect retrieval
		- under the hood of _cache.Get9), there are multiple nested try/catch blocks that error out if the redis server is down
		- if server down, the innner query is executed and results returned
		- while this would make system run a little slower and you see your db working harder, the system at least keeps running
2. now configure/resgiter the ef 
builder.Register(c => new DatabaseContext("Server=SQL_INSTANCE_NAME;Initial Catalog=DemoData;Integrated Security=True"))
    .As<IDatabaseContext>()
    .PropertiesAutowired()
    .InstancePerLifetimeScope();


Ex 4:
public class RedisSharedConnection
{
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        ConnectionMultiplexer connectionMultiplexer = ConnectionMultiplexer.Connect(ConfigurationManager.ConnectionStrings["RedisConnectionString"].ConnectionString);
        connectionMultiplexer.PreserveAsyncOrder = false;
        return connectionMultiplexer;
    });

    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
}

Simple integration of Redis cache to ASP.NET MVC
1. in controller class:
private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
{
    string cacheConnection = ConfigurationManager.AppSettings["CacheConnection"].ToString();
    return ConnectionMultiplexer.Connect(cacheConnection);
});

public static ConnectionMultiplexer Connection
{
    get
    {
        return lazyConnection.Value;
    }
}

2. add to webconfig
	<appSettings>
	  <add key="CacheConnection" value="MyCache.redis.cache.windows.net,abortConnect=false,ssl=true,password=..."/>
	</appSettings>

3. in the controller Index(actionType, resultType) Action method:
public ActionResult Index(string actionType, string resultType)
{
    List<Team> teams = null;

    switch(actionType)
    {
        case "playGames": // Play a new season of games.
            PlayGames();
            break;

        case "clearCache": // Clear the results from the cache.
            ClearCachedTeams();
            break;

        case "rebuildDB": // Rebuild the database with sample data.
            RebuildDB();
            break;
    }

    // Measure the time it takes to retrieve the results.
    Stopwatch sw = Stopwatch.StartNew();

    switch(resultType)
    {
        case "teamsSortedSet": // Retrieve teams from sorted set.
            teams = GetFromSortedSet();
            break;

        case "teamsSortedSetTop5": // Retrieve the top 5 teams from the sorted set.
            teams = GetFromSortedSetTop5();
            break;

        case "teamsList": // Retrieve teams from the cached List<Team>.
            teams = GetFromList();
            break;

        case "fromDB": // Retrieve results from the database.
        default:
            teams = GetFromDB();
            break;
    }

    sw.Stop();
    double ms = sw.ElapsedTicks / (Stopwatch.Frequency / (1000.0));

    // Add the elapsed time of the operation to the ViewBag.msg.
    ViewBag.msg += " MS: " + ms.ToString();

    return View(teams);
}
	
4. Add the following 3 methods to the controller class to  implement for cache maintenance

void PlayGames()
{
    ViewBag.msg += "Updating team statistics. ";
    // Play a "season" of games.
    var teams = from t in db.Teams
                select t;

    Team.PlayGames(teams);

    db.SaveChanges();

    // Clear any cached results
    ClearCachedTeams();
}
void RebuildDB()
{
    ViewBag.msg += "Rebuilding DB. ";
    // Delete and re-initialize the database with sample data.
    db.Database.Delete();
    db.Database.Initialize(true);

    // Clear any cached results
    ClearCachedTeams();
}
void ClearCachedTeams()
{
    IDatabase cache = Connection.GetDatabase();
    cache.KeyDelete("teamsList");
    cache.KeyDelete("teamsSortedSet");
    ViewBag.msg += "Team data removed from cache. ";
} 

5. add the following 4 methods to the controller class to implement different ways of retrieving the team stats form the cahce/db
- each method will return List<Team> which is rendered in View
List<Team> GetFromDB()
{
    ViewBag.msg += "Results read from DB. ";
    var results = from t in db.Teams
        orderby t.Wins descending
        select t; 

    return results.ToList<Team>();
}
List<Team> GetFromList()
{
    List<Team> teams = null;

    IDatabase cache = Connection.GetDatabase();
    string serializedTeams = cache.StringGet("teamsList");
    if (!String.IsNullOrEmpty(serializedTeams))
    {
        teams = JsonConvert.DeserializeObject<List<Team>>(serializedTeams);

        ViewBag.msg += "List read from cache. ";
    }
    else
    {
        ViewBag.msg += "Teams list cache miss. ";
        // Get from database and store in cache
        teams = GetFromDB();

        ViewBag.msg += "Storing results to cache. ";
        cache.StringSet("teamsList", JsonConvert.SerializeObject(teams));
    }
    return teams;
}
List<Team> GetFromSortedSet()
{
    List<Team> teams = null;
    IDatabase cache = Connection.GetDatabase();
    // If the key teamsSortedSet is not present, this method returns a 0 length collection.
    var teamsSortedSet = cache.SortedSetRangeByRankWithScores("teamsSortedSet", order: Order.Descending);
    if (teamsSortedSet.Count() > 0)
    {
        ViewBag.msg += "Reading sorted set from cache. ";
        teams = new List<Team>();
        foreach (var t in teamsSortedSet)
        {
            Team tt = JsonConvert.DeserializeObject<Team>(t.Element);
            teams.Add(tt);
        }
    }
    else
    {
        ViewBag.msg += "Teams sorted set cache miss. ";

        // Read from DB
        teams = GetFromDB();

        ViewBag.msg += "Storing results to cache. ";
        foreach (var t in teams)
        {
            Console.WriteLine("Adding to sorted set: {0} - {1}", t.Name, t.Wins);
            cache.SortedSetAdd("teamsSortedSet", JsonConvert.SerializeObject(t), t.Wins);
        }
    }
    return teams;
}
List<Team> GetFromSortedSetTop5()
{
    List<Team> teams = null;
    IDatabase cache = Connection.GetDatabase();

    // If the key teamsSortedSet is not present, this method returns a 0 length collection.
    var teamsSortedSet = cache.SortedSetRangeByRankWithScores("teamsSortedSet", stop: 4, order: Order.Descending);
    if(teamsSortedSet.Count() == 0)
    {
        // Load the entire sorted set into the cache.
        GetFromSortedSet();

        // Retrieve the top 5 teams.
        teamsSortedSet = cache.SortedSetRangeByRankWithScores("teamsSortedSet", stop: 4, order: Order.Descending);
    }

    ViewBag.msg += "Retrieving top 5 teams from cache. ";
    // Get the top 5 teams from the sorted set
    teams = new List<Team>();
    foreach (var team in teamsSortedSet)
    {
        teams.Add(JsonConvert.DeserializeObject<Team>(team.Element));
    }
    return teams;
}

5. in the Create(Team team) method of the controller, invoke the CearCachedTeams()
// POST: Teams/Create
// To protect from overposting attacks, please enable the specific properties you want to bind to, for 
// more details see http://go.microsoft.com/fwlink/?LinkId=317598.
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Create([Bind(Include = "ID,Name,Wins,Losses,Ties")] Team team)
{
    if (ModelState.IsValid)
    {
        db.Teams.Add(team);
        db.SaveChanges();
        // When a team is added, the cache is out of date.
        // Clear the cached teams.
        ClearCachedTeams();
        return RedirectToAction("Index");
    }

    return View(team);
}

6. in Edit(Team team) method, incoke ClearCachedTeams()
// POST: Teams/Edit/5
// To protect from overposting attacks, please enable the specific properties you want to bind to, for 
// more details see http://go.microsoft.com/fwlink/?LinkId=317598.
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Edit([Bind(Include = "ID,Name,Wins,Losses,Ties")] Team team)
{
    if (ModelState.IsValid)
    {
        db.Entry(team).State = EntityState.Modified;
        db.SaveChanges();
        // When a team is edited, the cache is out of date.
        // Clear the cached teams.
        ClearCachedTeams();
        return RedirectToAction("Index");
    }
    return View(team);
}
7. in DeleteConfirmed(int id) method of controller, invoke ClearCachedTeams
// POST: Teams/Delete/5
[HttpPost, ActionName("Delete")]
[ValidateAntiForgeryToken]
public ActionResult DeleteConfirmed(int id)
{
    Team team = db.Teams.Find(id);
    db.Teams.Remove(team);
    db.SaveChanges();
    // When a team is deleted, the cache is out of date.
    // Clear the cached teams.
    ClearCachedTeams();
    return RedirectToAction("Index");
}


Ex: performing various key-value get/sets: http://taswar.zeytinsoft.com/redis-for-net-developer-string-datatype/

var redis = RedisStore.RedisCache;
 
var key = "testKey";
           
if(redis.StringSet(key, "testValue"))
{
   var val = redis.StringGet(key);
 
   //output - StringGet(testKey) value is testValue
   Console.WriteLine("StringGet({0}) value is {1}", key, val);
 
   var v1 = redis.StringGetSet(key, "testValue2");
 
   //output - StringGetSet(testKey) testValue == testValue
   Console.WriteLine("StringGetSet({0}) {1} == {2}", key, val, v1);
 
   val = redis.StringGet(key);
 
   //output - StringGet(testKey) value is testValue2
   Console.WriteLine("StringGet({0}) value is {1}", key, val);
 
   //using SETNX 
   //code never goes into if since key already exist
   if (redis.StringSet(key, "someValue", TimeSpan.MaxValue, When.NotExists))
   {
      val = redis.StringGet(key);
      Console.WriteLine("StringGet({0}) value is {1}", key, val);
   }
   else
   {
      //always goes here
      Console.WriteLine("Value already exist");
   }
 
   var key2 = key + "1";
   if (redis.StringSet(key2, "someValue", TimeSpan.MaxValue, When.NotExists))
   {
      val = redis.StringGet(key2);
      //output - StringGet(testKey2) value is someValue", key2, val
      Console.WriteLine("StringGet({0}) value is {1}", key2, val);
   }
   else
   {
      //never goes here
      Console.WriteLine("Value already exist");
   }
}   

MULTIPLE key-value bulk 
KeyValuePair<RedisKey, RedisValue>[] values = {
   new KeyValuePair<RedisKey, RedisValue>("a", "x"),
   new KeyValuePair<RedisKey, RedisValue>("b", "y")
};
 
if (redis.StringSet(values))
{
   RedisKey[] myKeys = {"b", "a"};
   var allValues = redis.StringGet(myKeys);
 
   //output - y,x
   Console.WriteLine(string.Join(",", allValues));                
}   

SERIALZING
User u = new User {Name = "taswar", Twitter = "@taswarbhatti"};
 
var userKey = "user:taswar";
var serializedUser = JsonConvert.SerializeObject(u);
redis.StringSet(userKey, serializedUser);           
 
var u2 = JsonConvert.DeserializeObject<User>(redis.StringGet(userKey));
 
//output Name = taswar, Twitter = @taswarbhatti
Console.WriteLine("Name = {0}, Twitter = {1}", u2.Name, u2.Twitter);
