
	Configurations
		WebApiConfig.cs (Routing configurations)
		- where you configure the web routing, http handling, etc
		- the Register() method uses the HttpConfiguration object that contains the following configuration properties
			DependencyResolver: 
			Filters: action filters
			Formatters: Media-type formatters
			Initializers: performas final initialization of the HttpConfiguration object
			MessageHandlers: http message handler
			ParameterBeindingRules: similar to [FromBody], [Bind()] in asp core controller action parameters
			Properties: general property bag
			Routes: collection of routes and mappings
			Services: colleciton of services

		HttpConfiguration can be done few ways
		1. using a delegate with GlobalConfiguration
			- in the Global.asax's Application_Start() method
				GlobalConfiguration.Configure(cgf => 
				{
					cfg.MapHttpAttributeRoutes();
					cfg.Routes.MapHttpRoute(
						name: "DefaultApi",
						routeTemplate: "api/{controller}/{id}",
						defaults: new {id = RouteParameeter.Optional}
					);
				});
				this is similar to asp core, where it follows that structure with id? optional
			- every http request will go through this to be mapped


			static class WebApiConfig
			{
				public static void Register(HttpConfiguration config)
				{
					
				}
			}
		2. using a separate static WebApiCOnfig.cs file
			- must be inside the App_Start directory (for .net to detect it as a App_Start() configuration type)
			- class is static, and it contains a static method Register which uses the HttpConfiguration object

			public static class WebApiConfig
			{
				public static void Register(HttpConfiguration config)
				{
					config.MapHttpAttributeRoutes();
					config.Routes.MapHttpRoute(
						.... same as above
					);
				}
			}
			- now in the global.asax.cs file
			protected void Appliucation_Start()
			{
				GlobalConfiguration.Configure(WebApiConfig.Register);
			}

		Routing:
			routeTemplate: "api/{controller}/{id}": api/Contacts/2 => ContactsController
			- MUST have 'api' to detect as api route
			- the Action methods in controller need to be prepended with Get, Post, Delete, Update to differentiate so the URL mapping knows which to go to based on http request

			- if not prepending with the http types, use the attribute like asp core
			[HttpGet]
			public Product FindProduct(id){}

			- one action can take multiple http request types
			[AcceptVerbs("GET", "HEAD")]
			public Prodict FindProd(int id){}

			-you can also add the {action} like asp core
			routeTemplate: "api/{controller}/{action}/{id}"

			//for default values
			defaults: new { category = "all"}
			defaults: new { id = RouteParameter.Optional}

			//to add constraits
			constrants: new {id = @"\d+" }: id must be one or more numbers


			Starting from web API version 2
			- ccan use route attribute like asp core
			[Route("customers/{customerId}/orders")]
			public IEnumerable<Order> GetOrderesByCustomer(int id){}

			- to enable attribute routes, need to add to configuration in HttoConfiguration object
				public static void Register(HttpConfiguration config)
				{
					...
					config.MapHttpAttributeRoutes();

					config.Routes.MapHttpRoute(
						name: "DefualtApi",
						routeTemplate: "api/{con...}"
						defaults: new {...}
					
					);
					//NOTE: can have combination
				}

	HttpMessage Handlers:
		- class that receives requests and returns responses, they are the middleware for web api
		- cahined together just like asp core

		can create your own http handlers and register it in pipe ike like asp core
		public class MessageHandler1: Delegatinghandler
		{
			protected async override Task<HttpResponseMessage> SendAsync(
				HttpRequestMessage request, CancellationToken cts
			)
			{
				var response = await base.SendAsync(request, cts);
				return resposne
			}
		}

		//add to pipeline vial WebApiConfig.cs file
		public static class WebApiConfig
		{
			public static void Register(HttpConfiguration config)
			{
				config.MessageHandlers.Add(new MessageHandler1());
				config.MessageHandlers.Add(new MessageHandler2());
				...
			
			}
		}

		Ex: create handler to check each request for API key
		public class ApiKeyHandler : DelegatingHandler
{
    public string Key { get; set; }

    public ApiKeyHandler(string key)
    {
        this.Key = key;
    }

    protected override Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request, CancellationToken cancellationToken)
			{
				if (!ValidateKey(request))
				{
					var response = new HttpResponseMessage(HttpStatusCode.Forbidden);
					var tsc = new TaskCompletionSource<HttpResponseMessage>();
					tsc.SetResult(response);    
					return tsc.Task;
				}
				return base.SendAsync(request, cancellationToken);
			}

			private bool ValidateKey(HttpRequestMessage message)
			{
				var query = message.RequestUri.ParseQueryString();
				string key = query["key"];
				return (key == Key);
			}
		}

	Instread of having the delegate apply to every request, you can add it to a route so it only applies for that route
	//in webapiconfig.cs
	public static void Register(HttpConfiguration config)
    {
        config.Routes.MapHttpRoute(
            name: "Route1",
            routeTemplate: "api/{controller}/{id}",
            defaults: new { id = RouteParameter.Optional }
        );

        config.Routes.MapHttpRoute(
            name: "Route2",
            routeTemplate: "api2/{controller}/{id}",
            defaults: new { id = RouteParameter.Optional },
            constraints: null,
            handler: new MessageHandler2()  // per-route message handler
        );

        config.MessageHandlers.Add(new MessageHandler1());  // global message handler
    }

	Configure routes to handle specific delegates:
	//ni webapiconfig.cs
	// List of delegating handlers.
	DelegatingHandler[] handlers = new DelegatingHandler[] {
		new MessageHandler3()
	};

	// Create a message handler chain with an end-point.
	var routeHandlers = HttpClientFactory.CreatePipeline(
		new HttpControllerDispatcher(config), handlers);

	config.Routes.MapHttpRoute(
		name: "Route2",
		routeTemplate: "api2/{controller}/{id}",
		defaults: new { id = RouteParameter.Optional },
		constraints: null,
		handler: routeHandlers
	);

	Global Web API services:
		HttpConfiuration.Serivces property is collection cotaining set of global services 
			-ContentNegotiator, DocumentationProvider
			HttpActionInvoker, HttpActionSelector, FilterProvider, etc, etc

