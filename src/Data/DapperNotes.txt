3 step process:
	- Create IDbConnection instance
	- Write the query to perform CRUD
	- Pass query as parameter in Execute method

	string sqlInvoices = "SELECT * FROM Invoice;";
	string sqlInvoice = "SELECT * FROM Invoice where Id = @Id;";
	string sp = "exec Invoice_Insert;";

	using(var connection = My.ConnectionFactory()){
		var invoices = connection.Query<Invoice>(sqlInvoices).ToList();
		var invoice = connection.QueryFirstOrDefault(sqlInvoice, new {InvoiceID = 1});
		var affectedRows = connection.Execute(sp, new { Param1 = "Single_Insert_1"}, commandType: CommandType.StoredProcedure);
	}


Methods:
	Execute
	Query, QueryFirst, QueryFirstOrDefault, QuerySingle, QuerySingleOrDefault, QueryMultiple

Parameter: different parameter types can be used

	Anonymous: anonymous objects => Execute(sql, new {MyObject = Yo, ...})

	Dynamic: placeholder of @<name> then later in runtime (when executing, etc) replace with actual pariables

	List: 

	String:


Results: results returned can be mapped to => anonymous types, Strongly Typed, multi-result, multi-type, multi-mapping
	

Utilities: 
	Async: connection.QueryAsync<Invoice>(sql);

	Buffered: connection.Query<Invoice>(sql, buffered: false);

	Transaction: 
		using(var transaction = connection.BeginTransaction())
		{
			var affectedRows = connection.Execute(sql, new {...}, commandType: CommandType.StoredProcedure, transaction: transaction);
			transaction.Commit();
		}

	Stored Procedures:
		



Execute methods:
	can execute commands one or more times and return the number of affected rows
	used to execute: stored procedures, statements (insert, update, delete)

	Execute(sql, params = null, transaction: null, commandTimeout: null, commandType: null)

	By using a list: => new [] {param..}, the command executes the number of times == to size of the array