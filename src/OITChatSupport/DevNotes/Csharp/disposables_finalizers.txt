IDisposable
	- inherit via interface, or implement in class?

	Memory management and runtime engines in your application
		- in managed environments (.NET CLR, Java JVM, etc), heap allocations are resovled by the runtime engine (ie: CLR)
		- the runtime engine is the supervisor that knows every thing about heap allocations (ie: managed environment)
		- but the managed environemnt as a whole lives in less "managed environemnt" (ie: the operating system)
		- thus the applicatino may need resources not managed by the CLR (files in the system, external resources like DB ports for http clinet calls, etc)
		- but the environment still has to access to use it, so it does
	
	Thus there are 3 classifications of memory resources accessed by the.NET application
	1. CLR memory resources: 
		lives in the code, primitive data types, strings, reference objects, etc (all allocated on heap)
	
	2. Managed Resources: 
		MyConnectionFactory, FileHandler, etc
		- these are CLR references on the heap that access unmanaged resources and hold unmanaged fields/resources (db connections,e tc)
		- however the resource that houses it is CLR heap allocated
		
	3. Unmanaged resource
		all resources your app doesn't manage (databases, remote networks, windows/timers in the OS, etc, etc)

	The CLR onyl controls/manages its own .NET heap and uses its garbage collector (via algorithms)
	to manage this
		- the GC's objective is to reclaim the not reahable managed memory, then to recomapct it to prevent memory fragmentation
		- the GC algoirthm is non-deterministec so we don't know when the used memory on the heap will be de-allocated or whether
			it will even be deallocated at all!
	
	This problem led to .NET creating: 
	1. IDisposable inferface with void Dispose(){}
	2. The Dispose Pattern
	3. The Finalize() protected method defined at the System.Object level

	IDisposable:
		most of the time we don't care when the GC will reclaim the memroy, but sometimes
		for certain types (managed and unmanaged) we don't want those objects sating  in memory for long
		Ex: limited database connections in the pool, the unmanaged resources cling onto it...
		- some objects use Close(), Free(), Release() methods

		IDisposable came with one method: void Dispose(){} designed to standardize resource disposal

	Using():
		the using () scope was then designed  as a short, try-finally where the Dispose() method is invoked in teh finally block automatically

	override Finalize():
		this is only necessary if your class directly creates a native resource 
			Ex: class creates a memroy space in the unmanaged heap like a Graphics device interface or file handle
		- otherwise majority of .NET types that manage unmanaged resources already have IDisposable implemented and finalizers override
			Ex: Stream, DbConnection, etc

		- any instance with a finalize() method will add extra costs for reclaiming their CLR memory since itll take at LEAST 2 GC iterations
			first, puts object in "f-reachable" list
			then, runs finalizer(){} code
			then removes object from "f-reachable" list so object is now unreachable
			finally the heap memory will be reclaimed the next time around

	Destructor syntax: 
		code writting inside the destructor syntax is placed inside the Finalize(){} method internally by the C# compiler
		in a try-finally block with a call the the base class in the finally block
		- IE: the finalize() method is not a destructor, it houses the destructor via Compiler

	If your class has one+ unmanged resources, you will need to 
		1. override the Finalize() method
		2. Call GC.SuppressFinalize() from your void Dispose() method
		3. The Dispose() method must also release any managed/unmanaged resources
		4. The Dispose() can be invoked multiple times without failing
		5. Once the object is disposed, it can no longer be used (it is now garbage)
			- thus all public instance methods should raise ObjectDisposedException()
		6. Only release unmanged resources  Finalize() method (there should never by CLR or managed reousrces in there)


	How to implement disposables correctly
	1, any non-sealed class, even if you may not derive it anymore, someone else might
		- and if you believe that its derivation can require unmanaged resources, you should make 
		the finalization code (IDisposable + Finalize()) in the base class
	2. If exceptiosn are thrown in the constructor of an instance, the finalzier code will still be executed
		- make sure to check if fields for native resources have been correctly initialized before calling any clean up code
	3. Dispose(){}
		- should be callable multiple times without throwing exceptinos
		- must dispose all resources it owns
		- once disposed cannot be used anymore so all its public methods must throw the exception ObjectDisposedException
		- no delegates, events, etc can be pointing to it. you have 2 choices
			1. the instance running Disspose() exposes the events which is then unsubscribed from list of subscribers
				- good strategy is to define a OnDisposing event so all subscribing  code can register and have a change to be notified of it
			2. restrict subscribers to the instance running Dispose() so you can unsubscribe easily
	Native Handling
		the abstract class SafeHandle helps dispose native handles in a safe manner
		- most .NET classes that wrap native handles (files, pipes, wait handles, registry keys, etc) use interanlly special classes derived from the 
			Safe handle
		- You may want to if needed create/derive your own custom safehandle for disposing native handles



	https://superdevelopment.com/2014/03/13/common-pitfalls-with-idisposable-and-the-using-statement/
	https://stackoverflow.com/questions/538060/proper-use-of-the-idisposable-interface
	https://www.codeproject.com/Articles/15360/Implementing-IDisposable-and-the-Dispose-Pattern-P