DDD uses various tools and design patterns for its architecture
- some are used over others based on application needs
- the fundamental principle of DDD = bounded context
	1. bounded contexts are application context/features that are bounded 
	2. each bound can communicate to antoher via shared kernels, and other mechanisms
	3. the goal is to really differentiate between different paritions of what the app is supposed to do
	4. often useful for larger enterprise level projects, complex infrastures where integrating multiple servers, or integrating legacy code, etc

	Ex: chatbot app with agent support and admin data analytics
		- admin data = bounded context
		- agent support = bounded context
		- user - bot = bounded context

- Domain:
	- core of the application, consisting of entities, models, aggregate roots, value objects, domain events, etc, etc
	- the domain driven ==> must know and develop the domain prior to other infrastructure, UI, Web design, etc
	- difficult since the design is heavy 
	- uses various patterns based on app needs: CQRS, repository, event source
	https://github.com/zkavtaskin/Domain-Driven-Design-Example
	https://lostechies.com/jimmybogard/2010/02/04/strengthening-your-domain-a-primer/

Services: 3 types
	1. domain services: used to encapsulate business logica that doesn't naturally fit within a domain object
	2. application services: used by external consumers to talk to your system
	3. infrastructure services: used to abstract technoical concerns (data access, email senders, authenticaion providers, message queues, etc)

	Repositories:
		data access and  consistency checks
		- pure DDD ==> aggregate roots are responsible for consistency checks
		- in non-pure DDD, you can use checkes via domain services layer


Anemic vs Rich domain models
	anemic (plain): only getters and setters, no different from DTOs
	rich domain models (RDM): getters/setters, validators, etc
	https://www.codeproject.com/Articles/1056964/Anemic-data-models-ADM-VS-Rich-Data-Models-RDM-in
	https://www.devtrends.co.uk/blog/3-ways-to-avoid-an-anemic-domain-model-in-ef-core
	General summary to test
	https://www.codeproject.com/Tips/1076687/Are-You-Making-These-Domain-Driven-Design-Mista
	https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/domain-events-design-implementation
	http://www.tonytruong.net/domain-events-pattern-example/
	http://dddsamplenet.codeplex.com/SourceControl/changeset/view/48934#777714
	https://www.marccostello.com/using-domain-events/
	https://aspnetboilerplate.com/Pages/Documents/EventBus-Domain-Events
	https://softwareengineering.stackexchange.com/questions/213577/rich-domain-models-how-exactly-does-behavior-fit-in
	http://piotrgankiewicz.com/2016/08/01/handling-domain-events/

	event handling
	https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/how-to-subscribe-to-and-unsubscribe-from-events
	https://stackoverflow.com/questions/31273889/difference-between-event-action-and-event-eventhandlereventargs
	https://aspnetmonsters.com/2017/03/2017-03-24-masstransit1/
	http://www.c-sharpcorner.com/UploadFile/b81385/advances-in-net-event-handling/
	https://docs.microsoft.com/en-us/dotnet/csharp/event-pattern
	https://docs.microsoft.com/en-us/dotnet/csharp/modern-events


	https://www.codeproject.com/Articles/187230/What-not-to-do-Anti-Patterns-and-the-Solutions