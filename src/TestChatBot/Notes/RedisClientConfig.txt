Best practices StackExchange redis for .NET
1. Set AbortConnect=false to let ConnectionMultiplexer reconnect automatically
	Ex: (configurationOptions class)
		public static ConfigurationOptions GetConfiguration(string host, bool sll, string accessKey, string clientName)
		{
			var config = ConfigurationOptions.Parse(host);
			config.Ssl = ssl;
			config.ClientName = clietnName;
			config.AbortOnConnectFail = false;
			cnfig.Password = accessKey;
			return config;
		}
	Ex: (set in configuration file in connectino string)
		<connectionString="mycache.redis.cache.windows.net,abortConnect=false, ssl=true,password=..."></connectionString>
2. Reuse ConnecitonMultiplexer since it's static (don't create new per request)
3. Use Lazy<ConnectionMultiplexer> pattern
4. Configure ThreadPool settings to avoid timeouts
	- thread pools provide IOCP threads without throttling until it reaches the minimum number in configuration, after it starts causing delays
	- Note: thread pools for IOCP are shared with HTTP client connections, Sql Server connections, Redis, etc
	- set the minimum number configuration value for both IOCP and worker to larger than default value (100 is good start)

	To configure on .NET, 
		1. need Machine.config file that configures system level stuff in app
		2. <processModel 
			minIoThreads=100/>
		3. 100 starting point is PER CORE, (if you have 4 core machine and want minIOThreads=200 at runtime, <processModel minIoThreads="50" />)
	To configure outside of .NET 
		- if no Machine.config file given (since using cloud, remote server, etc), can configure using Application_Start() method in global.asax.cs
			Application_Start()
			{
				ThreadPool.SetMinThreads(
					int wokrerThreads,
					int completionPortThreads
				);
			}
		- using this api, threads is NOT per-core setting. if you want minIOThreads = 200 at runtime, pass 200 into the API
	To configure on .NET core
		- add Environment Variable: COMPlus_ThreadPool_ForceMinWorkerThreads, to overwrite default MinThreads setting according to the Environment/REgistry Configuration Knobs
		https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md

5. Performance costs for diffent operations
	Ex: "KEYS" command = O(n) operation  (expensive)

6. Consider turning on Server GC (WorkStation GC is default, but this can impact latency when garbage collection happens)
	<runtime> <gcServer enabled="true" /> </runtime>

7. Single multiplexer works for most part, but you can increase connection number to test throughput (don'tuse large numbers)

8. at times redis client fails to reconnect after connection blips (ie: due to patching, etc)
	- fix by restarting the client or creating a new multiplexer
	- use the recommended Lazy<Multi> while allowing apps to force reconnection periodically
	- update code calling the multiplexer to handle ObjectDisposedException that may result from disposing the old instance

	public static class Redis
	{
		static DateTimeOffset lastReconnectTime = DateTimeOffset.MinValue;
		static DateTimeOffset firstError = DateTimeOffset.MinValue;
		static DateTimeOffset priorError = DateTimeOffset.MinValue;

		static object reconnectLock = new object();
		//limit the frequency of force reconnecting since this occurs rarely... we want stack exchange to handle most reconnects
		public static TimeSpan ReconnectMinFrequency = TimeSpan.FromSeconds(60);

		//if errors continue longer than the below threshold, it indicates that multiplexer is not reconnecting, so re-create multiplexer
		public static TimeSpan ReconnectErrorThreshold = TimeSpan.FromSeconds(30);

		static string connectionString = "TODO: CALL InitializeConnectionString() method with connection string";
		static Lazy<ConnectionMultiplexer> multiplexer = CreateMultiplexer();
		public static COnnectionMultiplexer Connection=> multiplexer.Value;
		public static void InitialzeConnectionString(string cnString)
		{
			if(string.IsNullOrWhiteSpace(cnString))
				throw new ArgumentNullException(nameof(cnString));
			connectionString = cnString;
		}

		// force new Connection
		//1. Users of Multiplexer MUST handle ObjectDisposedExceptions which can now happen as result of calling ForceReconnect()
		// 2., Dont call ForceReconnect for Tiemouts, only RedisConnectionExceptions
		// 3. Call this method every time you see connection exception, the code will wait to reconnect:
			a. for at least the ReconnectError Threashold time of repeated errors before reconnecting
			b. not reconnect more freq than configured in ReconnectMinFrequency

		public static void ForceReconnect()
		{
			var utcNow = DateTimeOffset.UtcNow;
			var priorReconnect = lastReconnectTime;
			var elapsedSinceLastReconnect = utcNow - priorReconnect;
			if(elapsedSinceLastReconnect > ReconnectMinFrequency)
			{
				lock(reconnectLock)
				{
					utcNow = DateTimeOffset.UtcNow;
					elapsedSinceLastReconnect = utcNow - lastReconnectTime;
					if(firstError == DateTimeOffset.MinValue)
					{
						firstError = utcNow;
						priorError = utcNow;
						return;
					}
					if (elapsedSinceLastReconnect < ReconnectMinFrequency)
                    return; // Some other thread made it through the check and the lock, so nothing to do.

					var elapsedSinceFirstError = utcNow - firstError;
					var elapsedSinceMostRecentError = utcNow - previousError;

					var shouldReconnect = 
						elapsedSinceFirstError >= ReconnectErrorThreshold   // make sure we gave the multiplexer enough time to reconnect on its own if it can
						&& elapsedSinceMostRecentError <= ReconnectErrorThreshold; //make sure we aren't working on stale data (e.g. if there was a gap in errors, don't reconnect yet).

					// Update the previousError timestamp to be now (e.g. this reconnect request)
					previousError = utcNow;

					if (shouldReconnect)
					{
						firstError = DateTimeOffset.MinValue;
						previousError = DateTimeOffset.MinValue;

						var oldMultiplexer = multiplexer;
						CloseMultiplexer(oldMultiplexer);
						multiplexer = CreateMultiplexer();
						lastReconnectTime = utcNow;
					}
				}
			}
		}
		private static Lazy<ConnectionMultiplexer> CreateMultiplexer()
		{
			return new Lazy<ConnectionMultiplexer>(() => ConnectionMultiplexer.Connect(connectionString));
		}

		private static void CloseMultiplexer(Lazy<ConnectionMultiplexer> oldMultiplexer)
		{
			if (oldMultiplexer != null)
			{
				try
				{
					oldMultiplexer.Value.Close();
				}
				catch (Exception)
				{
					// Example error condition: if accessing old.Value causes a connection attempt and that fails.
				}
			}
		}
	}
Optional configuration:
	Set connectionTimeout:
		10000
	if (RedisConn == null)
        { 
            ConfigurationOptions option = new ConfigurationOptions
            {
                AbortOnConnectFail = false,
                EndPoints = { redisEndpoint }
            };
            RedisConn = ConnectionMultiplexer.Connect(option);
        }

Serialization types: Json, Binary, MessagePack, Protobuff, etc

2 layer model to combine local cache and redis, or redis and db
	Ie: first check cache, if not in get from DB, then bring back, etc, etc
