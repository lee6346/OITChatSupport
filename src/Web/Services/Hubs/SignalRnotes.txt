Overview:
	SignalR: 
		Hubs: represents a connection (ws, long-polling, etc) that is used for SignalR to push and receive information
			- Hub classes are mapped to a URI end point
			- If multiple users in a single Uri Hub, you can differentiate using Group names or User Ids
		
		Hub Features and Options: can use message pack or JSON for serialization, and encode in 64 base, ASCII, etc
		
		Hub transfer mode: can set underlying to binary or text

		Hub Context


		Hub Connection Context: Contains relevant information about a hub connection 
			to include CancellationTokens, connection Id, authorization policies of users, Exception handlers, 
			internal Feature collections for socket contexts

		Hub Connection List: contains a dictionary of connection IDs and its mapped connection contexts
			can remove, add, get count of, etc of connection contexts from the list

		Hub Activators: Responsible for Creating and Releasing (disposing) of hubs during runtime

		Proxies: Client proxies can be used to invoke methods on behalf of others
			UserProxy, GroupProxy, AllClientProxy, SingleClientProxy, ...

		Hub Managers: have control over Hub operations 
			Group MAnagers: limited to adding and removing connections via group names
			LifetimeManagers: can invoke methods for any group, user, client, hub, and can handle hub connections/disconnections



Application features/constraints:
	= Supports Binary protocol based on Message Pack, and text protocol based on JSON
	- contains extensions to create custom protocols
	- allows streaming of data rather than send-> complete
	- can connect to signal R server without any client in a single request
	- use redis to scale out applications
	- no automatic reconnects when connection drops (user on client side must be notified on dropped connection and manually reconnect)
	- sticky sessions: once client connects to a server it must use that server (assuming you are using server farms)
	- only one Hub per connection, but you can have multiple connections per HUB

	CLient side:
	- you can use lower level socket library instead of hubs. This allows the client side to use raw JS or rxjs web sockets to make web socket connections
	- you can also use C# system.net.client websockets to connect to the signal r socket lib or even the signal r hub (as long as its ws and not long polling, etc)




Dependencies
	MsBuild: <PackageReference Include="Microsoft.AspNetCore.SignalR" Version="1.0.0-alpha1-final" />
	Node/JS Client: 
		$ npm install @aspnet/signalr-client
		.cshtml => <script src="scripts/signalr-client.min.js"></script>

	Optional: if wanting to use SignalR managed clients include in MSBuild.NOTE: we will use JS/TS clients, not C# clients
		<PackageReference Include="Microsoft.AspNetCore.SignalR.Client" Version="1.0.0-alpha1-final" />

Startup:
	1. Create a Hub
		public class Chat: Hub
		{
			Public Task Send(string message)
			{
				return Clients.All.InvokeAsync("Send", message);
			}	
		}
	2. Configure services and Configure:
		services.AddSignalR();
		..
		app.UseSignalR(routes => {
			routes.MapHub<Chat>("chat");
		});

Client connection (TS or JS)
	let connection = new signalR.HubConnection('/chat');

	connection.on('send', data => {
		console.log(data);
	});

	connection.start()
			.then(() => connection.invoke('send', 'Hello'));


Streaming data Via IObservable or ReadableChannel (ex: stock tickers, etc)
	public IObservable<Stock> StreamStocks()
	{
		return _stockTicker.StreamStocks()
	}

	//client
	function startStreaming(){
		connection.stream("StreamStocks").subscribe({
			next: displayStocks,
			error: function(err) {
				logger.log(err);
			}
		});
	}

	

	1. Injecting in controller constructor:
		Controller(IHubContext<Chat> _chatContext){
			chatContext = _chatContext
		}




	2. using in angular: https://damienbod.com/2017/09/12/getting-started-with-signalr-using-asp-net-core-and-angular/
		rather than injecting in <scripts> tag, in the services/component you can apply it
		
		import {HubConnection } from '@aspnet/signalr-client';
		private _hubCOnnection: HubConnection;
		public async: any;
		message = '';
		messages: string[] = [];
		constructor(){}
		public sendMessage(): void {
			const data = `Sent: ${this.message}`;
			this._hubConnection.invoke('Send', data);
			this.messages.push(data);
		}

		//on the ngOnInit(), we will subscribe (without using RxJS??)
		ngOnInit(){
			this._hubConnection = new HubCOnnection('/chat');
			this._hubConnection.on('Send', (data: any) => {
				const received = `Received: ${data}`;
				this.messages.push(received);
			});
			this._hubConnection.start()
				.then(() => {
					console.log('Hub connection started')
				})
				.catch(err => {
					console.log('Error.while establishing connection')
				});
			}
		}
		Note; for production: add uglifyjs-webpack plugin to package.json. then in webpack production: new UglifyJSPlugin({ parallel: { cache: true, wrokers: 2}})


	3. restrictions in a hub
	//ChatHub.cs
		public override Task OnConnectedAsync()
        {
            return base.OnConnectedAsync();
        }

        public async Task MoveShape(int x , int y)
        {
            //This will be simpler once there is support for Others or when AllExcept has a params overload
            await Clients.AllExcept(new List<string> { Context.ConnectionId }).InvokeAsync("shapeMoved", x, y);
        }


		Samples:
			Using angular: 
				https://github.com/damienbod/AspNetCoreAngularSignalR
				https://damienbod.com/2017/09/18/signalr-group-messages-with-ngrx-and-angular/


			Misc:
				https://github.com/aspnet/SignalR-samples
				https://github.com/DamianEdwards/SignalR

	4. creating your own methods in a derived hub
		public class Hub4 : Hub
		{
			public Task Draw(int prevX, int prevY, int currentX, int currentY, string color)
			{
				return Clients.AllExcept(new List<string> { Context.ConnectionId }).InvokeAsync("draw", prevX, prevY, currentX, currentY, color);
			}
		
		
		}


	5. Stock tickrs:
		//Stock.cs
		public class Stock
		{
			private decimal _price;
			public string Symbol {get; set;}
			public decimal DayOpen {get; private set;}
			public decimal DayLow {get; private set;}
			public decimal DayHigh {get; private set;}
			public decimal LastChang {get; private set;}
			public decimal Change
			{
				get{ return Price - DayOpen;}
			}
			public double PercentChange
			{
				get { return (double)Math.Round(Change/Price, 4)}
			}

			pubic double Price
			{
				get { return _price; }
				set {
					if (_price == value)
					{
						return;
					}
					LastChange = value - _price;
					_price = value;
					if(DayOpen == 0){
						DayOpen = _price;
					}
					if(_price < DayLow || DayLow == 0)
					{
						DayLow = _price;
					}
					if(_price > DayHigh)
					{
						DayHigh = _price;
					}
				
				}
			}
		}

		//StockTicker.cs
		public class StockTicker
		{
			private readonly SemaphoreSlim _marketStateLock = new SemaphoreSlim(1, 1);
			private readonly SemaphoreSlim _updateStockPricesLock = new SemphoreSlim(1, 1);

			private readonly ConcurrentDictionary<string, Stock> _stocks = new ConcurrentDictionary<string, Stock>();

			private readonly double _rangePercent = 0.002;
			private TimeSpan _updateInterval = TimeSpan.FromMilliseconds(250);
			private readonly Random _updateOrNotRandom = new Random();

			private Timer _timer;
			private volatile bool _updatingStockPirces;
			private volatile MarketState _marketState;

			public StockTicker(IHubContext<StockTickerHub> clients)
			{
				Clients = clients;
				LoadDefaultStocks();
			}
			private IHubContext<StockTickerHub> Clients
			{
				get;
				set;
			}
			private MarketState MarketState
			{
				get {return _marketState;}
				private set{ _marketState = value;}
			}
			public IEnumerable<Stock> GetAllStocks()
			{
				return _stocks.Values;
			}

			public IObservable<Stock> StreamStocks()
			{
				return Observable.Create(
					async (IObserver<Stock> observer) =>
					{
						while (MarketState == MarketState.Open)
						{
							foreach (var stock in _stocks.Values)
							{
								observer.OnNext(stock);
							}
							await Task.Delay(_updateInterval);
						}
					});
			}

			public async Task OpenMarket()
			{
				await _marketStateLock.WaitAsync();
				try
				{
					if(MarketState != MarketState.Open)
					{
						_timer = new Timer(UpdateStockPrices, null, _updateInterval, _updateInterval);
						MarketState = MarketState.Open;
						await BroadcastMarketStateChange(MarketState.Open);
					}
				}
				finally
				{
					_marketStateLock.Release();
				}
			}
			publiuc async Task CloseMarket()
			{
				await _marketStateLock.WaitAsync();
				try
				{
					if(MarketState == MarketState.Open)
					{
						if(_timer != null)
						{
							_timer.DIspose();
						}

						MarketState = MarketState.Closed;
						await BroadcastMarketStateChange(MarketState.Closed);
					}
				}
				finally
				{
					_marketStateLock.Release();
				}
			
			}

			public async Task Reset()
			{
				await _marketStateLock.WaitAsync();
				try{
					if(MarketState != MarketState.Closed)
					{
						throw new InvalidOperationException("Market must be closed prior to resetting");
					}
					LoadDefaultStocks();
					await BroadcastMarketReset();
				}
				finally
				{
					_marketStateLock.Release();
				}
			}
			public void LoadDefaultStocks()
			{
				_stocks.Clear();
				var stocks = new List<Stock>
				{
					new Stock { Symbol = "MSFT", Price = 75.12m},
					new Stock { Symbol = "AAPL", Price = 158.44m}
				};
				stocks.ForEach(stock => _stocks.TryAdd(stock.Symbol, stock));
			}

			public async void UpdateStockPrices(object state)
			{
				await _updateStockPricesLock.WaitAsync();
				try
				{
					if(!_updatingStockPrices)
					{
						_updatingStockPrices = true;
						foreach (var stock in _stocks.Values)
						{
							TryUpdateStockPrice(stock);
						}
						_updatingStockPrices = false;
					}
				}
				finally
				{
					_updateStockPricesLock.Release();
				}
			}

			private bool TryUpdateStockPrice(Stock stock)
			{
				var r = _updateOrNotRandom.NextDouble();
				if(r > 0.1)
				{
					return false;
				}
				var random = new Random((int)Math.Floor(stock.Price));
				var percentChange = random.NextDouble() * _rangePercent;
				var pos = random.NextDouble() > 0.51;
				var change = Math.Round(stock.Price * (decimal)percentChange, 2);
				change = pos ? change : -change;
				stock.Price += change;
				return true;

			}

			public async Task BroadcastMarketStateChange(MarketState marketState)
			{
				switch(marketState)
				{
					case MarketState.Open:
						await Clients.Clients.All.InvokeAsync("marketOpened");
						break;
					case MarketState.Closed:
						await Clients.Clients.All.InvokeAsync("marketClosed");
						break;
					default:
						break;
				}
			}

			private async Task BroadcastMarketReset()
			{
				await Clients.Cleints.All.InvokeAsync("marketReset");
			}

			private async Task BroadcastStockPrice(Stock stock)
			{
				await Clients.Clients.All.InvokeAsync("updateStockPrice", stock);
			}


		}

		public enum MarketState
		{
			Closed,
			Open
		}

	//StockTickerHub.cs
		public class StockTickerHub : Hub
		{
			private readonly StockTicker _stockTicker;
			public  StockTickerHub(StockTicker stockTicker)
			{
				_stockTicker = stockTicker;
			}

			public IEnumerable<Stock> GetAllStocks()
			{
				return _stockTicker.GetAllStocks();
			}

			public IObservable<Stock> StreamStocks()
			{
				return _stockTicker.StreamStocks();
			}

			public string GetMarketState()
			{
				return _stockerTicker.MarketState.ToString();
			}

			public async Task OpenMarket()
			{
				await _stockTicker.OpenMarket();
			}

			public async Task CloseMarket()
			{
				await _stockTicker.CloseMarket();
			}

			public async Task Reset()
			{
				await _stockTicker.Reset();
			}
		
		}

	// since we are using nested services, the hub must also be separately registered in the collection
		services.AddSignalR();
		services.AddScoped<StockTickerHub>();
		services.AddSingleton<StockTicker>();

		...
		app.UseSignalR(routes => {
			routes.MapHub<StockTickerHub>("stocks");
		});



6. This sample shows implementing a client using C sharp without any signal R (just plain web sockets from the system.net library)
	//Program.cs
	public static void Main(string[] args)
	{
		RunWebSockets.
	}

	public static async Task RunWebSockets()
	{
		var ws = new ClientWebSockets();
		await ws.ConnectAsync(new Uri("ws://localhost:5000/chat/wa"), CacnellationToken.None);

		Console.WriteLine("connected");

		var sending = Task.Run(async() => 
		{
			string line;
			while(( line = Console.ReadLine()) != null)
			{
				var bytes = Encoding.UTF8.GetBytes(line);
				await ws.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, endOfMessage: true, cancellationToken: CancellationToken.None);
			}

			await ws.CloseOutputAsync(WebSocketCloseStatus.NormalClosure, "", CancellationToken.Non);
		});
		var receiving = Receiving(ws);
		await Task.WhenAll(sending, receiving);
	}

	private static async Task Receiving(ClientWebSocket ws)
	{
	
		var buffer = new byte[2048];
		while(true)
		{
			var result = await ws.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
			if(result.MessageType == WebSocketMessageType.Text)
			{
				Console.WRiteLine(Encoding.UTF8.GetString(buffer, 0, result.Count));
			}
			else if(result.MessageType == WebSocketMessage.Binary)
			{
			
			}
			else if(result.MessageType == WbeSocketMessage.Close)
			{
				await ws.CloseOutputAsync(WebSocketCloseStatus.NormalClosure, "", CancellationToken.None);
				break;
			}
		}
	}

7. this example shows a variety of Hub types to create using sockets
	//Person.cs
	class Person
	{
		public string Name {get; set;}
		public long Age {get; set;}
	}

	//MessagePoint.cs
	class messagesEndPoint : EndPoint
	{
		public ConnectionList Connections {get; } = new ConnectionList();
		public override async Task OnConnectedASync(ConnectionContext connection)
		{
			Connections.Add(connection);
			await Broadcast($"{connection.ConnectionId} connected ({connection.Metadata[ConnectionMetadataNames.Transport]})");

			try
			{
				while(await connection.Transport.In.WaitToReadAsync())
				{
					if(connection.Transport.In.WaitTOReadAsync())
					{
						var text = Encoding.UTF8.GetString(buffer);
						text = $"{connection.ConnectionId}: {text}";
						await Broadcast(Encoding.UTF8.GetBytes(text));
					}
				}

			}
			finally
			{
				Connections.Remove(connection);
				await Broadcast($"{connection.ConnectionId} disconnected ({connection.Metadata[ConnectionMetadataNames.Transport]})");

			}
		}
		private Task Broadcast(string text)
		{
			return Broadcast(Encoding.UTF8.GetBytes(text));
		}
		private Task Broadcast(byte[] payload)
		{
			var tasks = new List<Task>(Connections.Count);
			foreach(var c in Connections)
			{
				tasks.Add(c.Transport.Out.WriteAsync(payload));
			}
			return Task.WhenAll(tasks);
		}
	}


	//Startup.cs.. NOTE: since we are using sockets as well has hubs, we must include both
	services.AddSockets();
	services.AddSignalR();

	app.UseSignalR(routes => {
	
		routes.MapHub<DynamicChat>("dynamic");
		routes.MapHub<Chat>("default");
		routes.MapHub<Streaming>("streaming");
		routes.MapHub<HubTChat>("hubT");
	});

	app.UseSockets(routes => 
	{
		routes.MapEndPoint<MessagesEndPoint>("chat");
	});


	//Streaming.cs

	public class Streaming: Hub
	{
	
		public IObservable<int> ObservableCounter(int count, int delay)
		{
			return Observable.Interval(TimeSpan.FromMilliseconds(delay))
				.select((_, index) => index)
				.Take(count);
		}

		public ReadableChannel<int> ChannelCounter(int count, int delay)
		{
			var channel = Channel.CreateUnbounded<int>();

			Task.Run(async() => {
				for(var i = 0; i < count; i++)
				{
					await channel.Out.WriteAsync(i);
					await Task.Delay(delay);
				}
				channel.Out.TryComplete();
			
			});
			return channel.In;
		}
	}

	//HubTChat.cs

	public class HubTChat : Hub<IChatClient>
	{
		public override async Task OnConnectedAsync()
		{
			await Clients.All.Send($"{Context.ConnectionId} joined");
		}

		public override async Task OnDisconnectedAsync(Exception ex)
		{
			await Clients.All.Send($"{Context.ConnectionId} left");
		}
		public Task Send(string message)
		{
			return Clients.All.Send($"{Context.ConnectionId}: {message}");
		}

		ppublic Task SendToGroup(string groupName, string message)
		{
			return Clients.Group(groupName).Send($"{Context.ConnectionId}@{groupName}: {message}");
		}

		public async Task JoinGroup(string groupName)
		{
			await Groups.AddAsync(Context.ConnectionId, groupName);
			await Clients.Group(groupName).Send($"{Context.ConnectionId} joined {groupName}");
		}

		public async Task LeaveGroup(string groupName)
		{
			await Groups.RemoveAsync(Context.ConnectionId, groupName);
			await Clients.Group(groupName).Send($"{Context.ConnectionId} left {groupName}");
		}

		public Task Echo(string message)
		{
			return Clients.Client(Context.ConnectionId).Send($"{Context.ConnectionId}: {message}");
		}

	
	
	}
	public interface IChatClient
	{
		Task Send(string message);
	}


	//Chat.cs
	public class Chat : Hub
    {
        public override async Task OnConnectedAsync()
        {
            await Clients.All.InvokeAsync("Send", $"{Context.ConnectionId} joined");
        }

        public override async Task OnDisconnectedAsync(Exception ex)
        {
            await Clients.All.InvokeAsync("Send", $"{Context.ConnectionId} left");
        }

        public Task Send(string message)
        {
            return Clients.All.InvokeAsync("Send", $"{Context.ConnectionId}: {message}");
        }

        public Task SendToGroup(string groupName, string message)
        {
            return Clients.Group(groupName).InvokeAsync("Send", $"{Context.ConnectionId}@{groupName}: {message}");
        }

        public async Task JoinGroup(string groupName)
        {
            await Groups.AddAsync(Context.ConnectionId, groupName);

            await Clients.Group(groupName).InvokeAsync("Send", $"{Context.ConnectionId} joined {groupName}");
        }

        public async Task LeaveGroup(string groupName)
        {
            await Groups.RemoveAsync(Context.ConnectionId, groupName);

            await Clients.Group(groupName).InvokeAsync("Send", $"{Context.ConnectionId} left {groupName}");
        }

        public Task Echo(string message)
        {
            return Clients.Client(Context.ConnectionId).InvokeAsync("Send", $"{Context.ConnectionId}: {message}");
        }
    }


	//DynamicChat.cs
	public class DynamicChat : DynamicHub
    {
        public override async Task OnConnectedAsync()
        {
            await Clients.All.Send($"{Context.ConnectionId} joined");
        }

        public override async Task OnDisconnectedAsync(Exception ex)
        {
            await Clients.All.Send($"{Context.ConnectionId} left");
        }

        public Task Send(string message)
        {
            return Clients.All.Send($"{Context.ConnectionId}: {message}");
        }

        public Task SendToGroup(string groupName, string message)
        {
            return Clients.Group(groupName).Send($"{Context.ConnectionId}@{groupName}: {message}");
        }

        public async Task JoinGroup(string groupName)
        {
            await Groups.AddAsync(Context.ConnectionId, groupName);

            await Clients.Group(groupName).Send($"{Context.ConnectionId} joined {groupName}");
        }

        public async Task LeaveGroup(string groupName)
        {
            await Groups.RemoveAsync(Context.ConnectionId, groupName);

            await Clients.Group(groupName).Send($"{Context.ConnectionId} left {groupName}");
        }

        public Task Echo(string message)
        {
            return Clients.Client(Context.ConnectionId).Send($"{Context.ConnectionId}: {message}");
        }
    }


8. Create a social weather notification. use different message formatting: NOTE => using the lower level sockets libs
	//FormatterResolver.cs: convert the format of streamed data 
	public class FormatterResolver
    {
        private IServiceProvider _serviceProvider;

        private Dictionary<string, Dictionary<Type, Type>> _formatters
            = new Dictionary<string, Dictionary<Type, Type>>();

        public FormatterResolver(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }

        public void AddFormatter<T, TFormatterType>(string formatType)
            where TFormatterType : IStreamFormatter<T>
        {
            Dictionary<Type, Type> typeFormatters;
            if (!_formatters.TryGetValue(formatType, out typeFormatters))
            {
                typeFormatters = _formatters[formatType] = new Dictionary<Type, Type>();
            }
            typeFormatters[typeof(T)] = typeof(TFormatterType);
        }

        public IStreamFormatter<T> GetFormatter<T>(string formatType)
        {
            Dictionary<Type, Type> typeFormatters;
            Type typeFormatterType;
            if (_formatters.TryGetValue(formatType, out typeFormatters) &&
                typeFormatters.TryGetValue(typeof(T), out typeFormatterType))
            {
                return (IStreamFormatter<T>)_serviceProvider.GetRequiredService(typeFormatterType);
            }

            return null;
        }
    }

	//IStreamFormatter.cs
	public interface IStreamFormatter<T>
    {
        Task<T> ReadAsync(Stream stream);
        Task WriteAsync(T value, Stream stream);
    }

	//PersistentConnectionLifeTimeManager.cs
	public class PersistentConnectionLifeTimeManager
    {
        private readonly FormatterResolver _formatterResolver;
        private readonly ConnectionList _connectionList = new ConnectionList();

        public PersistentConnectionLifeTimeManager(FormatterResolver formatterResolver)
        {
            _formatterResolver = formatterResolver;
        }

        public void OnConnectedAsync(ConnectionContext connection)
        {
            connection.Metadata["groups"] = new HashSet<string>();
            connection.Metadata["format"] = "json";
            _connectionList.Add(connection);
        }

        public void OnDisconnectedAsync(ConnectionContext connection)
        {
            _connectionList.Remove(connection);
        }

        public async Task SendToAllAsync<T>(T data)
        {
            foreach (var connection in _connectionList)
            {
                var context = connection.GetHttpContext();
                var formatter = _formatterResolver.GetFormatter<T>((string)connection.Metadata["format"]);
                var ms = new MemoryStream();
                await formatter.WriteAsync(data, ms);

                connection.Transport.Out.TryWrite(ms.ToArray());
            }
        }

        public Task InvokeConnectionAsync(string connectionId, object data)
        {
            throw new NotImplementedException();
        }

        public Task InvokeGroupAsync(string groupName, object data)
        {
            throw new NotImplementedException();
        }

        public Task InvokeUserAsync(string userId, object data)
        {
            throw new NotImplementedException();
        }

        public void AddGroupAsync(ConnectionContext connection, string groupName)
        {
            var groups = (HashSet<string>)connection.Metadata["groups"];
            lock (groups)
            {
                groups.Add(groupName);
            }
        }

        public void RemoveGroupAsync(ConnectionContext connection, string groupName)
        {
            var groups = (HashSet<string>)connection.Metadata["groups"];
            if (groups != null)
            {
                lock (groups)
                {
                    groups.Remove(groupName);
                }
            }
        }
    }
		
	//SocialWeahterEndPoint.cs
	public class SocialWeatherEndPoint : EndPoint
    {
        private readonly PersistentConnectionLifeTimeManager _lifetimeManager;
        private readonly FormatterResolver _formatterResolver;
        private readonly ILogger<SocialWeatherEndPoint> _logger;

        public SocialWeatherEndPoint(PersistentConnectionLifeTimeManager lifetimeManager,
            FormatterResolver formatterResolver, ILogger<SocialWeatherEndPoint> logger)
        {
            _lifetimeManager = lifetimeManager;
            _formatterResolver = formatterResolver;
            _logger = logger;
        }

        public async override Task OnConnectedAsync(ConnectionContext connection)
        {
            _lifetimeManager.OnConnectedAsync(connection);
            await ProcessRequests(connection);
            _lifetimeManager.OnDisconnectedAsync(connection);
        }

        public async Task ProcessRequests(ConnectionContext connection)
        {
            var formatter = _formatterResolver.GetFormatter<WeatherReport>(
                (string)connection.Metadata["formatType"]);

            while (await connection.Transport.In.WaitToReadAsync())
            {
                if (connection.Transport.In.TryRead(out var buffer))
                {
                    var stream = new MemoryStream();
                    await stream.WriteAsync(buffer, 0, buffer.Length);
                    stream.Position = 0;
                    var weatherReport = await formatter.ReadAsync(stream);
                    await _lifetimeManager.SendToAllAsync(weatherReport);
                }
            }
        }
    }

	//JsonStreamFormatter.cs
	public class JsonStreamFormatter<T> : IStreamFormatter<T>
    {
        private JsonSerializer _serializer = new JsonSerializer();

        public async Task<T> ReadAsync(Stream stream)
        {
            var reader = new JsonTextReader(new StreamReader(stream));
            // REVIEW: Task.Run()
            return await Task.Run(() => _serializer.Deserialize<T>(reader));
        }

        public Task WriteAsync(T value, Stream stream)
        {
            var writer = new JsonTextWriter(new StreamWriter(stream));
            _serializer.Serialize(writer, value);
            writer.Flush();
            return Task.FromResult(0);
        }
    }
	//pipeweatherstreamformatter
	public class PipeWeatherStreamFormatter : IStreamFormatter<WeatherReport>
    {
        public async Task<WeatherReport> ReadAsync(Stream stream)
        {
            var sr = new StreamReader(stream);
            var line = await sr.ReadLineAsync();

            if (line == null)
            {
                return null;
            }

            var tokens = line.Split('|');
            int temperature;
            long reportTime = long.MinValue;
            Weather weather = (Weather)(-1);
            string zipCode = tokens.Length > 3 ? tokens[3] : string.Empty;

            if (tokens.Length == 0 || !int.TryParse(tokens[0], out temperature))
            {
                temperature = int.MinValue;
            }

            if (tokens.Length < 2 || !long.TryParse(tokens[1], out reportTime))
            {
                temperature = int.MinValue;
            }

            if (tokens.Length < 3 || !Enum.TryParse<Weather>(tokens[2], out weather))
            {
                weather = (Weather)(-1);
            }

            return new WeatherReport
            {
                Temperature = temperature,
                ReportTime = reportTime,
                Weather = weather,
                ZipCode = zipCode
            };
        }

        public async Task WriteAsync(WeatherReport report, Stream stream)
        {
            var sw = new StreamWriter(stream);
            var line = $"{report.Temperature}|{report.ReportTime}|{(int)report.Weather}|{report.ZipCode ?? string.Empty}";

            Encoding utf8 = Encoding.UTF8;
            var encodedBytes = utf8.GetBytes(line);
            var convertedBytes = Encoding.Convert(Encoding.UTF8, Encoding.ASCII, encodedBytes);

            await sw.WriteLineAsync(Encoding.ASCII.GetString(convertedBytes));
            await sw.FlushAsync();
        }
    }

	//WeatherReport.cs

	public enum Weather { Sunny, MostlySunny, PartlySunny, PartlyCloudy, MostlyCloudy, Cloudy }

    public class WeatherReport
    {
        public int Temperature { get; set; }

        public long ReportTime { get; set; }

        [JsonConverter(typeof(StringEnumConverter))]
        public Weather Weather { get; set; }

        public string ZipCode { get; set; }
    }


	//Startup.cs
	services.AddRouting();
    services.AddSockets();
    services.AddEndPoint<SocialWeatherEndPoint>();
    services.AddTransient<PersistentConnectionLifeTimeManager>();
    services.AddSingleton(typeof(JsonStreamFormatter<>), typeof(JsonStreamFormatter<>));
    services.AddSingleton<PipeWeatherStreamFormatter>();
    services.AddSingleton<ProtobufWeatherStreamFormatter>();
    services.AddSingleton<FormatterResolver>();

	app.UseSockets(o => { o.MapEndPoint<SocialWeatherEndPoint>("weather"); });
	var formatterResolver = app.ApplicationServices.GetRequiredService<FormatterResolver>();
            formatterResolver.AddFormatter<WeatherReport, JsonStreamFormatter<WeatherReport>>("json");
            formatterResolver.AddFormatter<WeatherReport, ProtobufWeatherStreamFormatter>("protobuf");
            formatterResolver.AddFormatter<WeatherReport, PipeWeatherStreamFormatter>("pipe");
